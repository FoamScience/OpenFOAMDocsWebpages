#!/usr/bin/env bash
# This script was generated by bashly 1.2.10 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
odw_usage() {
  printf "odw - Opinionated API and unit-testing docs for OpenFOAM-related projects\n\n"

  printf "%s\n" "Usage:"
  printf "  odw COMMAND\n"
  printf "  odw [COMMAND] --help | -h\n"
  printf "  odw --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate or update API docs for what's in src/ folder, with support for unit test linking\n" "docs"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "FOAM_SRC (required)"
    printf "    Source your OpenFOAM environment.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "DOCS_DIR (required)"
    printf "    Set the root folder of the Hugo repository where the docs should be stored.\n    Currently, this maps to: API docs -> content/en/api/libs*, without touching\n    content/en/api/_index.md UT  docs -> content/en/tests/libs* ADRS     ->\n    content/en/adr\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CODE_SRC_DIR (required)"
    printf "    Set the src folder of the C++ sources to document. This is where your\n    libraries reside.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CODE_TEST_DIR"
    printf "    Set the tests folder for the unit tests. Enabling this will turn on unit\n    tests processing.\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "FOAM_FOAMUT"
    printf "    Point to where foamUT should be cloned. Set to /dev/null if not doing unit\n    tests; Also, if testCases folder exists on the same level as $CODE_TEST_DIR,\n    the test cases are copied over.\n"
    echo

  fi
}

# :command.usage
odw_docs_usage() {
  printf "odw docs - Generate or update API docs for what's in src/ folder, with support for unit test linking\n\n"

  printf "%s\n" "Usage:"
  printf "  odw docs DATABASES_FOLDER [OPTIONS]\n"
  printf "  odw docs --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--foamcd-config, -c FOAMCD-CONFIG"
    printf "    Template foamcd-config. Some entries are not honored even if provided within\n    this config: - markdown.project_name - parser.compile_commands_dir -\n    database.path\n"
    echo

    # :flag.usage
    printf "  %s\n" "--plugin-list, -p PLUGIN-LIST"
    printf "    FoamCD plugins to load, comma-separated. Eg. \"openfoam,openfoam_reflection\"\n"
    printf "    %s\n" "Conflicts: --foam-config"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "DATABASES_FOLDER"
    printf "\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  DOCS_DIR=~/repos/MyHugoSite/ CODE_SRC_DIR=~/repos/myLibs/src ./odw docs\n  /tmp/foamcd.dbs\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/unittests.sh
#!/usr/bin/env bash
# Expects:
# - CODE_SRC_DIR to be set
# - CODE_TEST_DIR to be set
# - DOCS_DIR to be set
# - FOAM_FOAMUT to be set
# - Tested libraries are already compiled
unittests() {
    # Prep work
    if [ -d "$FOAM_FOAMUT" ] ; then
        rm -rf "$FOAM_FOAMUT"
    fi
    git clone https://github.com/FoamScience/foamUT "$FOAM_FOAMUT"
    rm -rf "$FOAM_FOAMUT/tests/exampleTests"
    test_cases_path=$(realpath "$(dirname $CODE_TEST_DIR)/testCases")
    if [ -d "$test_cases_path" ]; then
        rm -rf "$FOAM_FOAMUT"/cases
        cp -r "$test_cases_path" "$FOAM_FOAMUT/cases"
    fi
    branch=$(cd "$CODE_TEST_DIR" && git branch --show-current)
    remote=$(cd "$CODE_TEST_DIR" && git remote get-url origin)
    TESTS_DOCS="$DOCS_DIR/content/en/tests"
    mkdir -p "$TESTS_DOCS"
    mkdir -p "$FOAM_FOAMUT/reports/docs"
    # Patch Alltest to produce compile_commands while reporting UT results
    sed -i 's/wmake > log.wmake/bear -- wmake > log.wmake/g' "$FOAM_FOAMUT/Alltest"
    # Find and link tests
    test_libs=$(find "$CODE_TEST_DIR" -type d -name "Make" -printf '%h\n' | sort -u)
    for lib in $test_libs; do
        link_path="$FOAM_FOAMUT/tests/$(basename "$lib")"
        if [ -L "$link_path" ]; then
            echo "link to $lib already exists..."
        else
            ln -s "$lib" "$link_path"
        fi
    done
    # Compile and run tests
    libs=$(find -L "$FOAM_FOAMUT"/tests -maxdepth 1 -mindepth 1 -type d)
    for lib in $libs; do
        libname=$(basename "$lib")
        echo "Unit tests for lib ${libname}"
        if ! test -f "$TESTS_DOCS/${libname}/_index.md"; then
            mkdir -p "$TESTS_DOCS/${libname}"
            printf -- "---\ntitle: ${libname} tests\nlayout: unittest\n---" >  "$TESTS_DOCS/${libname}/_index.md"
        fi
        files=$(find -L "$lib" -name '*Tests.C')
        for file in $files; do
            name=$(basename -- "$file")
            mkdir -p "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}"
            echo "Processing $name"
            # TODO: For now, on each test file, recompile to get the compile_commands.json
            #       right, this is inefficient...
            (cd "$FOAM_FOAMUT" && rm -rf "$lib/testDriver" && wclean "$lib" && ./Alltest --no-parallel --report  -# "[#${name%.C}]")
            mv "$FOAM_FOAMUT/reports/${libname}"* "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}"
            echo "Generating docs for $TESTS_DOCS/${libname}/${name%.C}.md"
            uvx --from foamcd foamcd-unittests "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}" "$TESTS_DOCS/${libname}/${name%.C}.md" "$remote" "$branch"
        done
    done
    # Consolidate all compilation dbs
    find "$CODE_TEST_DIR/" -name compile_commands.json -exec cat {} + | jq -s 'add' > "$CODE_TEST_DIR/compile_commands.json"
    if jq -e 'length == 0' "$CODE_TEST_DIR/compile_commands.json" > /dev/null; then
      echo "$CODE_TEST_DIR/compile_commands.json is empty. This is unexpected. Clean UT builds and retry"
      exit 1
    fi
}

# :command.command_functions
# :command.function
odw_docs_command() {

  # src/docs_command.sh
  #!/usr/bin/env bash
  echo "+==========================+"
  echo "| Updating API and UT Docs |"
  echo "+==========================+"

  if [[ -n "$CODE_TEST_DIR" && -z "$FOAM_FOAMUT" ]] || [[ -z "$CODE_TEST_DIR" && -n "$FOAM_FOAMUT" ]]; then
    echo "Error: Both CODE_TEST_DIR and FOAM_FOAMUT must be set, or both must be unset."
    exit 1
  fi

  generate_config=false
  if [[ -n "${args[--foamcd_config]}" ]]; then
    if [[ ! -f "${args[--foamcd_config]}" ]]; then
      echo "Error: File does not exist: ${args[foamcd_config]}"
      exit 1
    fi
  else
    echo "foamcd-config was not provided, will generate one on the fly"
    generate_config=1
  fi
  mkdir -p "${args[databases_folder]}"
  make_dirs=$(find "$CODE_SRC_DIR" -type d -name "Make" -printf '%h\n' | sort -u)
  do_unit_tests=false
  if [[ ${args[--with-unit-tests]} ]]; then
    do_unit_tests=${args[--with-unit-tests]}
  fi

  url_mappings='['
  for dir in $make_dirs; do
      url_mappings+="{ \"base_url\":\"\", \"path\":\"$dir\", \"pattern\":\"{{base_url}}/api/{{namespace}}_{{name}}\"}, "
  done
  url_mappings="${url_mappings%, }]"
  filename_uri='{{git_repository}}/blob/{{git_reference}}/{{file_path}}#L{{start_line}}-L{{end_line}}'

  for dir in $make_dirs; do
    if [[ ! -f "$dir/compile_commands.json" ]]; then
      echo "Generating compile_commands.json for $dir"
      (cd "$dir"; wclean; bear -- wmake) || echo "Compilation failed, now we chck for valid compile_commands.json"
      if jq -e 'length == 0' "$dir/compile_commands.json" > /dev/null; then
        echo "$dir/compile_commands.json is empty. This is unexpected. Clean builds and retry"
        exit 1
      fi
    fi
  done

  if [[ $do_unit_tests == 1 ]]; then
    unittests
  fi

  for dir in $make_dirs; do
    echo "API docs for $dir"
    lib_name=$(basename "$dir")
    tmp_lib="${args[databases_folder]}"
    mkdir -p "$tmp_lib"

    test_dir=""
    if [[ $do_unit_tests == 1 ]]; then
      test_dir=$(realpath "$CODE_TEST_DIR")
    fi
    if [[ $generate_config == false ]]; then
      cp "${args[--foamcd_config]}" "$tmp_lib/$lib_name.yaml"
      uvx --from foamcd foamcd-parse -g "$tmp_lib/$lib_name.yaml" \
        +markdown.project_name="$lib_name" \
        +parser.compile_commands_dir="$dir" \
        +database.path="$tmp_lib/$lib_name.db"
    else
      plugin_list='["openfoam"]'
      if [[ -n "${args[--plugin-list]}" ]]; then
        IFS=',' read -ra plugins <<< "${args[--plugin-list]}"
        plugin_list=$(printf '"%s",' "${plugins[@]}")
        plugin_list="[${plugin_list%,}]"
      fi

      uvx --from foamcd foamcd-parse -g "$tmp_lib/$lib_name.yaml" \
        +markdown.project_name="$lib_name" \
        +markdown.url_mappings="$url_mappings" \
        +markdown.filename_uri=$filename_uri \
        +markdown.method_doc_uri=$filename_uri \
        +markdown.frontmatter.entities.unit_tests="${do_unit_tests}" \
        +markdown.frontmatter.entities.unit_tests_compile_commands_dir="$test_dir" \
        +database.path="$tmp_lib/$lib_name.db" \
        +parser.compile_commands_dir="$dir" \
        +parser.plugins.only_plugins="$plugin_list" \
        +parser.prefixes_to_skip='["/usr/include", "/usr/include/x86_64-linux-gnu", "'"$FOAM_SRC"'"]' \
        +parser.include_paths='["/usr/lib/gcc/x86_64-linux-gnu/13/include"]'
    fi
    uvx --from foamcd foamcd-parse --config "$tmp_lib/$lib_name.yaml"
    uvx --from foamcd foamcd-markdown --config "$tmp_lib/$lib_name.yaml" --db "$tmp_lib/$lib_name.db" --output "$DOCS_DIR/content/en/api/$lib_name"
  done

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        odw_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("FOAM_SRC")
  env_var_names+=("DOCS_DIR")
  env_var_names+=("CODE_SRC_DIR")
  env_var_names+=("CODE_TEST_DIR")
  env_var_names+=("FOAM_FOAMUT")
  if [[ -z "${FOAM_SRC:-}" ]]; then
    printf "missing required environment variable: FOAM_SRC\n" >&2
    exit 1
  fi
  if [[ -z "${DOCS_DIR:-}" ]]; then
    printf "missing required environment variable: DOCS_DIR\n" >&2
    exit 1
  fi
  if [[ -z "${CODE_SRC_DIR:-}" ]]; then
    printf "missing required environment variable: CODE_SRC_DIR\n" >&2
    exit 1
  fi

  # :command.dependencies_filter
  missing_deps=
  # :dependency.filter
  if ! command -v uv >/dev/null 2>&1; then
    printf "missing dependency: uv\n" >&2
    printf "%s\n\n" "UV is required to manage python dependencies - to install it: \`curl -LsSf https://astral.sh/uv/install.sh | sh\`" >&2
    missing_deps=1
  else
    deps['uv']="$(command -v uv | head -n1)"
  fi

  # :dependency.filter
  if ! command -v bear >/dev/null 2>&1; then
    printf "missing dependency: bear\n" >&2
    printf "%s\n\n" "Bear is required to generate compilation databases - https://github.com/rizsotto/Bear" >&2
    missing_deps=1
  else
    deps['bear']="$(command -v bear | head -n1)"
  fi

  # :dependency.filter
  if ! command -v jq >/dev/null 2>&1; then
    printf "missing dependency: jq\n" >&2
    printf "%s\n\n" "jq is used to process compilation databases - https://jqlang.org/" >&2
    missing_deps=1
  else
    deps['jq']="$(command -v jq | head -n1)"
  fi

  # :dependency.filter
  if ! command -v git >/dev/null 2>&1; then
    printf "missing dependency: git\n" >&2
    printf "%s\n\n" "Git is used to fetch branch/reference info from local repositories" >&2
    missing_deps=1
  else
    deps['git']="$(command -v git | head -n1)"
  fi

  if [[ -n $missing_deps ]]; then
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    docs)
      action="docs"
      shift
      odw_docs_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      odw_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
odw_docs_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        odw_docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="docs"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --foamcd-config | -c)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--foamcd-config']="$2"
          shift
          shift
        else
          printf "%s\n" "--foamcd-config requires an argument: --foamcd-config, -c FOAMCD-CONFIG" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --plugin-list | -p)
        # :flag.conflicts
        if [[ -n "${args['--foam-config']:-}" ]]; then
          printf "conflicting options: %s cannot be used with %s\n" "$key" "--foam-config" >&2
          exit 1
        fi

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--plugin-list']="$2"
          shift
          shift
        else
          printf "%s\n" "--plugin-list requires an argument: --plugin-list, -p PLUGIN-LIST" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['databases_folder']+x} ]]; then
          args['databases_folder']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['databases_folder']+x} ]]; then
    printf "missing required argument: DATABASES_FOLDER\nusage: odw docs DATABASES_FOLDER [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "docs") odw_docs_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  initialize
  run "$@"
fi
