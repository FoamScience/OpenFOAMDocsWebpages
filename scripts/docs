#!/usr/bin/env bash
# This script was generated by bashly 1.1.9 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
docs_usage() {
  if [[ -n $long_usage ]]; then
    printf "docs - API and unit-testing docs for OpenFOAM-related projects\n"
    echo

  else
    printf "docs - API and unit-testing docs for OpenFOAM-related projects\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  docs COMMAND\n"
  printf "  docs [COMMAND] --help | -h\n"
  printf "  docs --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate or update API docs for what's in src/ folder\n" "api      "
  printf "  %s   Generate or update docs for the unit tests ran by foamUT\n" "unittests"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "FOAM_ETC (required)"
    printf "    Source your OpenFOAM environment\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "DOCS_DIR (required)"
    printf "    Set the root folder of the Hugo repository where the docs should be stored\n"
    echo

  fi
}

# :command.usage
docs_api_usage() {
  if [[ -n $long_usage ]]; then
    printf "docs api - Generate or update API docs for what's in src/ folder\n"
    echo

  else
    printf "docs api - Generate or update API docs for what's in src/ folder\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  docs api\n"
  printf "  docs api --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  DOCS_DIR=~/repos/MyProjectDocs/ ./docs api\n"
    echo

  fi
}

# :command.usage
docs_unittests_usage() {
  if [[ -n $long_usage ]]; then
    printf "docs unittests - Generate or update docs for the unit tests ran by foamUT\n"
    echo

  else
    printf "docs unittests - Generate or update docs for the unit tests ran by foamUT\n"
    echo

  fi

  printf "Alias: ut\n"
  echo

  printf "%s\n" "Usage:"
  printf "  docs unittests\n"
  printf "  docs unittests --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "FOAM_FOAMUT (required)"
    printf "    Set the path to your foamUT clone\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  FOAM_FOAMUT=/tmp/foamUT DOCS_DIR=~/repos/MyProjectDocs/ ./docs ut\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.command_functions
# :command.function
docs_api_command() {
  # src/api_command.sh
  #!/usr/bin/env bash
  echo "Updating API Docs"
  _repo_root=$(git rev-parse --show-toplevel)
  cd "$_repo_root" || exit
  blacklist_dirs=$(find src/ \( -type d -iname animations -o -type d -iname lnInclude -o -type d -iname Make \) | while read -r dir; do   echo "--input.blacklist_dir ${dir#src/}"; done)
  includes=$(find $PWD -type d -iname lnInclude | while read -r dir; do   echo "-I${dir}"; done)
  compile_commands=$(find src/ -type f -name compile_commands.json | while read -r cc; do echo  "--input.blacklist_file ${cc#src/}"; done)
  openfoam_includes=$(find src -type f -name compile_commands.json -exec jq -r '[.[] | .arguments[] | select(startswith("-I"))] | unique[]'  {} \;)
  pip install -r "$DOCS_DIR"/scripts/requirements.txt
  set -e
  standardese src \
      -DNoRepository -DOPENFOAM=2306 -DWM_DP -DWM_LABEL_SIZE=32 -fPIC -ftemplate-depth-100 \
      $includes \
      $openfoam_includes \
      --compilation.standard=c++20 \
      --input.source_ext ".H" \
      --input.source_ext ".C" \
      $blacklist_dirs \
      $compile_commands \
      --input.force_blacklist 1 \
      --comment.command_character "@" \
      --output.link_prefix "/api/"
  rm -f "$DOCS_DIR/content/en/api/headers/doc*md"
  for fl in doc_*md standardese*md; do
      python "$DOCS_DIR"/scripts/process-fm.py $fl
  done
  rm doc_*md standardese*md
  cd -

}

# :command.function
docs_unittests_command() {
  # src/unittests_command.sh
  #!/usr/bin/env bash
  _repo_root=$(git rev-parse --show-toplevel)
  curr_pwd=$PWD
  cd "$_repo_root" || exit
  echo "Updating Docs for unit tests"
  if [ -d "$PWD/testCases" ]; then
      rm -rf "$FOAM_FOAMUT"/cases
      cp -r "$PWD/testCases" "$FOAM_FOAMUT/cases"
  fi
  set +e
  TESTS_DOCS="$DOCS_DIR/content/en/tests"
  mkdir -p "$TESTS_DOCS"
  mkdir -p "$FOAM_FOAMUT/reports/docs"
  export MESHFREE_TESTS=$PWD/tests
  export MESHFREE_SRC=$PWD/src
  rm -rf "$FOAM_FOAMUT/tests/exampleTests"
  libs=$(find "$PWD/tests" -maxdepth 1 -mindepth 1 -type d)
  for lib in $libs; do
      link_path="$FOAM_FOAMUT/tests/$(basename "$lib")"
      if [ -L "$link_path" ]; then
          echo "link to $lib already exists..."
      else
          ln -s "$lib" "$link_path"
      fi
  done
  libs=$(find -L "$FOAM_FOAMUT"/tests -maxdepth 1 -mindepth 1 -type d)
  for lib in $libs; do
      libname=$(basename "$lib")
      echo "Unit tests for lib ${libname}"
      if ! test -f "$TESTS_DOCS/${libname}/_index.md"; then
          mkdir -p "$TESTS_DOCS/${libname}"
          printf -- "---\ntitle: Unit Tests\nlayout: unittests\n---" >  "$TESTS_DOCS/${libname}/_index.md"
      fi
      files=$(find -L "$lib" -name '*Tests.C')
      echo $files
      for file in $files; do
          name=$(basename -- "$file")
          mkdir -p "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}"
          echo "Processing $name"
          cd "$FOAM_FOAMUT" || exit
          ./Alltest --no-parallel --report  -# "[#${name%.C}]"
          mv "$FOAM_FOAMUT/reports/${libname}"* "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}"
          cd - || exit
          echo "Generating docs for $TESTS_DOCS/${libname}/${name%.C}.md"
          $DOCS_DIR/scripts/unittest-docs.py "$FOAM_FOAMUT/reports/docs/${libname}/${name%.C}" "$TESTS_DOCS/${libname}/${name%.C}.md"
      done
  done
  set -e
  cd "$curr_pwd" || exit

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        docs_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("FOAM_ETC")
  env_var_names+=("DOCS_DIR")
  if [[ -z "${FOAM_ETC:-}" ]]; then
    printf "missing required environment variable: FOAM_ETC\n" >&2
    exit 1
  fi
  if [[ -z "${DOCS_DIR:-}" ]]; then
    printf "missing required environment variable: DOCS_DIR\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    api)
      action="api"
      shift
      docs_api_parse_requirements "$@"
      shift $#
      ;;

    unittests | ut)
      action="unittests"
      shift
      docs_unittests_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      docs_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
docs_api_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        docs_api_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.dependencies_filter
  if command -v python >/dev/null 2>&1; then
    deps['python']="$(command -v python | head -n1)"
  else
    printf "missing dependency: python\n" >&2
    printf "%s\n" "Python is required to process generated docs." >&2
    exit 1
  fi

  if command -v pip >/dev/null 2>&1; then
    deps['pip']="$(command -v pip | head -n1)"
  else
    printf "missing dependency: pip\n" >&2
    printf "%s\n" "Pip is required to make sure Python dependencies are installed." >&2
    exit 1
  fi

  if command -v standardese >/dev/null 2>&1; then
    deps['standardese']="$(command -v standardese | head -n1)"
  else
    printf "missing dependency: standardese\n" >&2
    printf "%s\n" "standardese is required to generate the docs - https://github.com/standardese/standardese" >&2
    exit 1
  fi

  if command -v jq >/dev/null 2>&1; then
    deps['jq']="$(command -v jq | head -n1)"
  else
    printf "missing dependency: jq\n" >&2
    printf "%s\n" "jq is required to parse compile_commands.json files" >&2
    exit 1
  fi

  # :command.command_filter
  action="api"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
docs_unittests_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        docs_unittests_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("FOAM_FOAMUT")
  if [[ -z "${FOAM_FOAMUT:-}" ]]; then
    printf "missing required environment variable: FOAM_FOAMUT\n" >&2
    exit 1
  fi

  # :command.command_filter
  action="unittests"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  version="0.0.1"
  long_usage=''
  set -e

}

# :command.run
run() {
  declare -A args=()
  declare -A deps=()
  declare -a other_args=()
  declare -a env_var_names=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "api") docs_api_command ;;
    "unittests") docs_unittests_command ;;
  esac
}

initialize
run "$@"
