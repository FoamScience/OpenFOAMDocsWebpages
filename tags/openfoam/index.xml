<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MeshFreeFoam API Docs â€“ openfoam</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/</link><description>Recent content in openfoam on MeshFreeFoam API Docs</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 05 Oct 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://foamscience.github.io/MeshFreeFoam-Docs/tags/openfoam/index.xml" rel="self" type="application/rss+xml"/><item><title>Blog: Runtime selection mechanism for `MeshFreeFoam`</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</link><pubDate>Mon, 28 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/28/runtime-selection-mechanism-for-meshfreefoam/</guid><description>
&lt;p>In short, I&amp;rsquo;ll stick with OpenFOAM&amp;rsquo;s way of doing things when it comes to:&lt;/p>
&lt;ul>
&lt;li>RunTime Selection of models&lt;/li>
&lt;li>The plugin system (Function Objects)&lt;/li>
&lt;/ul>
&lt;h2 id="issue-01-dependency-on-the-openfoam-version">Issue 01: Dependency on the OpenFOAM version&lt;/h2>
&lt;p>I have decided to run with the master branch from &lt;a href="https://develop.openfoam.com/Development/openfoam">OpenCFD&amp;rsquo;s OpenFOAM&lt;/a>, and the very first issue I encounter is that the RunTime selection mechanism has changed somewhere between &lt;code>v2012&lt;/code> and &lt;code>v2306&lt;/code>. Not cool.&lt;/p>
&lt;p>So, my solution is to have my own macros for runtime selection, but in the end, they need to be compatible with the version I compile my toolkit with. This is exactly why dependency management will be a challenge on its own.&lt;/p>
&lt;h2 id="issue-02-going-too-far-with-ood-and-effects-on-gpu-optimization">Issue 02: Going too far with OOD and effects on GPU optimization&lt;/h2>
&lt;p>When I look at all public projects which are optimizing for GPU offloading (Here is an &lt;a href="https://github.com/exapde/Exasim">example&lt;/a>), there seems to be no tolerance for virtual methods. Actually, NVIDIA explicitly advises moving away from object-oriented design.&lt;/p>
&lt;p>While this is not an option for us, the plan is to have two modes:&lt;/p>
&lt;ul>
&lt;li>One mode employing the standard way of doing things in OpenFOAM in terms of RTS&lt;/li>
&lt;li>A second mode which either leverages &lt;code>dynamicMesh&lt;/code> or some kind of &lt;a href="https://github.com/jmmartinez/easy-just-in-time">&lt;code>JIT compiler&lt;/code>&lt;/a> to generate de-virtualized code at runtime.&lt;/li>
&lt;/ul></description></item><item><title>Blog: Introducing unit tests with foamUT</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/introducing-unit-tests-with-foamut/</guid><description>
&lt;p>Well, there are three clear objects for unit testing:&lt;/p>
&lt;ul>
&lt;li>Making sure new code does not break older functionality&lt;/li>
&lt;li>Making sure new functionality works as expected&lt;/li>
&lt;li>Making sure important dependency APIs have not changed without us noticing&lt;/li>
&lt;/ul>
&lt;p>To this end, I originally crafted the &lt;a href="https://github.com/FoamScience/foamUT">foamUT&lt;/a> toolkit to unit-test OpenFOAM code in a streamlined way. All that is needed is to write by-library tests and supply the appropriate &lt;code>Make/files&lt;/code> and &lt;code>Make/options&lt;/code> files to compile them. Example tests are provided in the &lt;a href="https://github.com/FoamScience/MeshFreeFoam/tree/master/tests">MeshFreeFoam&lt;/a> repository.&lt;/p>
&lt;p>Unit tests marvelously demonstrate usage of different code entities so I thought we would add them to the documentation website. Head to &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/tests">tests&lt;/a> to browse all unit tests and see their latest states.&lt;/p>
&lt;p>Currently, this feature relies on parsing Catch2 XML reports and I doubt this will change. Of course, at this point,&lt;br />
I&amp;rsquo;m only supporting simple test case reports. I&amp;rsquo;ll expand as I go.&lt;/p></description></item><item><title>Blog: Optimization notes: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</link><pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/08/29/optimization-notes-part-1/</guid><description>
&lt;h2 id="kdtree-and-radius-based-searches">KdTree and radius-based searches&lt;/h2>
&lt;p>When it comes to k-nearest neighbor (KNN) searches with unsorted radius queries in C++, I&amp;rsquo;ve decided to utilize &lt;a href="https://github.com/jlblancoc/nanoflann">nanoflann&lt;/a> as the backend for these operations.&lt;/p>
&lt;p>Their API is user-friendly, but there&amp;rsquo;s a specific challenge with the dynamic &lt;code>KdTree&lt;/code>. During my testing of the KdTree wrapper, I noticed that modifying the list of point positions for searches can be tricky. To address this, I&amp;rsquo;ve implemented a solution where I hash the current list and compare it before each KNN search.&lt;/p>
&lt;p>If the point list has undergone significant changes, the KdTree index becomes invalid and needs resetting. However, if the list only receives new points without alterations to old ones, I simply add the new points to the index.&lt;/p>
&lt;p>At this point, I have three key unanswered questions:&lt;/p>
&lt;ul>
&lt;li>What&amp;rsquo;s the efficiency of hashing the point list?&lt;/li>
&lt;li>How efficient is OpenFOAM&amp;rsquo;s implementation of the Jenkins hasher?&lt;/li>
&lt;li>Is resetting the KdTree index efficient compared to removing all points and adding the new ones?&lt;/li>
&lt;/ul></description></item><item><title>Blog: Lazy Evaluation: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/27/lazy-evaluation-part-1/</link><pubDate>Wed, 27 Sep 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/27/lazy-evaluation-part-1/</guid><description>
&lt;div style="position:relative;padding-bottom:56.25%;">
&lt;iframe style="width:100%;height:100%;position:absolute;left:0px;top:0px;" frameborder="0" width="100%" height="100%" allowfullscreen="" allow="autoplay" src="./LazyEvaluationAnimation.html">
&lt;/iframe>
&lt;/div>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>I used to think of OpenFOAM&amp;rsquo;s &lt;code>tmp&lt;/code> class template as a memory management thing (which is correct). After having some suspicions, I had a discussion with &lt;a href="https://www.linkedin.com/in/holger-marschall-62175683/">@holger&lt;/a> on the details of using &lt;code>tmp&lt;/code> to get things out of function scope. As I&amp;rsquo;ve skimmed through the code, I started to think of it as a lazy evaluation thing (which is not true). The main reason was that I would encounter operations of this signature &lt;code>tmp&amp;lt;T&amp;gt; BINARY_FUNCTION(T vf1, T vf2)&lt;/code> more and more.&lt;/p>
&lt;p>So, I went and added Info statements to the fields constructors, and discovered that&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#333">=&lt;/span> b &lt;span style="color:#333">+&lt;/span> c &lt;span style="color:#333">+&lt;/span> d; &lt;span style="color:#888">// as fields
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>would not construct two (from eagerly-doing the plus operations) but just one temporary object is created. This tricked me into thinking that those operations are done lazily. In fact, The same memory is reused for both operations, which does save up on memory allocation, but memory reads/writes still get carried out at the same spots as in traditional eager evaluation.&lt;/p>
&lt;p>It seems that &lt;code>tmp&lt;/code> was originally designed to optimize memory handling which has improved a lot in newer C++ standards. A recent C++ compiler performs move construction/assignment on return statements instead of copying which makes &lt;code>tmp&lt;/code> redundant in this regard:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Assume Field&amp;lt;scalar&amp;gt; has a move constructor and assignment operator
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>scalarField &lt;span style="color:#06b;font-weight:bold">add&lt;/span>(&lt;span style="color:#080;font-weight:bold">const&lt;/span> scalarField&lt;span style="color:#333">&amp;amp;&lt;/span> a, &lt;span style="color:#080;font-weight:bold">const&lt;/span> scalarField&lt;span style="color:#333">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> a &lt;span style="color:#333">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scalarField &lt;span style="color:#06b;font-weight:bold">c&lt;/span>(add(a,b)); &lt;span style="color:#888">// This will move-construct c from result of a+b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Older compilers will do a copy; that&amp;#39;s why most functions return a tmp
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Thus, &lt;code>tmp&lt;/code> has nothing to do with lazy evaluation, but computing linear combinations of stuff is all we do in CFD, and MeshFreeFoam is no exception. Being able to compute ${\bf x_1} + a {\bf x_2}$ efficiently is crucial. Here is the landscape of how efficient we can be:&lt;/p>
&lt;ul>
&lt;li>Regular C++: compute $a {\bf x_2}$ then add it to ${\bf x_1}$. Which is too wasteful (keeps allocating and discarding temporary memory chunks).&lt;/li>
&lt;li>With OpenFOAM&amp;rsquo;s &lt;code>tmp&lt;/code>: saves on new memory allocation on addition but is still wasteful when it comes to CPU cycles.&lt;/li>
&lt;li>&lt;strong>(?)&lt;/strong> With lazy evaluation: perform operations only when needed and at the tightest memory scope possible.&lt;/li>
&lt;/ul>
&lt;p>Despite being a .Net language, F# (and most of other functional languages) nailed on-demand computation. In an attempt to bring that level of functionality to my PhD project, I investigate how would lazy evaluation be implemented for OpenFOAM-based code.&lt;/p>
&lt;h2 id="lazy-evaluation-with-expression-templates">Lazy evaluation with expression templates&lt;/h2>
&lt;p>The first candidate was expression templates. I have heard of this concept countless times before. I even had my own my matrix implementation that allowed to perform operations only on a subset of rows/columns lazily. While that is not so useful now, being familiar with the concept helps. Also, with C++17 and newer standards, the implementation of expression templates has become much easier compared to five or six years back.&lt;/p>
&lt;p>One inherent drawback of a rigorous implementation of expression templates is that they can add some considerable complexity to the code in regard of ordering computations:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// Assume &amp;lt;&amp;lt;, + and * are implemented with expression templates
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>a &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> b &lt;span style="color:#333">+&lt;/span> c; &lt;span style="color:#888">// using &amp;lt;&amp;lt; to denote that this is not an assignment; take it as a mere labeling operation
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// a not used, so, let&amp;#39;s not compute it yet
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>b &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>; &lt;span style="color:#888">// now this is an assignment
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>d &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> a &lt;span style="color:#333">*&lt;/span> &lt;span style="color:#00d;font-weight:bold">2&lt;/span>; &lt;span style="color:#888">// Which values of b were used here? b = 1; but was that intended?
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>That said, the performance benefit of implementing expression templates is enormous. It&amp;rsquo;s at least 50% faster than eager evaluation for &lt;a href="https://github.com/FoamScience/Eager-TemplateExpr-Views-OpenFOAM/blob/80c59112d5660cd24630e4c57c6f7648c8a0b8c7/expressionTemplatesVsViewsTests.C#L30">few operations&lt;/a> (addition, multiplication, subtraction and division of scalar arrays).&lt;/p>
&lt;p>Thus, the next best thing, is a partial template expression system which evaluates on assignment to avoid the confusion, so not truly lazy, but somewhere in between. Even then, I will have to maintain the whole system while keeping it compatible with OpenFOAM&amp;rsquo;s API. Instead, I started to look at the news ranges from C++20 standard library.&lt;/p>
&lt;h2 id="lazy-evaluation-with-views">Lazy evaluation with views&lt;/h2>
&lt;p>In particular, C++20 introduces &lt;code>views&lt;/code> which are special kinds of ranges which do not own their data. For our purposes, think of them as views into (parts of) the CFD fields. These were perfect for other purposes too, for example, implementation of fit-in-L2-cache subdomains for MeshFreeFoam.&lt;/p>
&lt;p>The biggest problem with views is the thin compiler support. For example, to use &lt;code>zip_transform&lt;/code> which allows to do operations on multiple views at one (eg. binary functions), we have to use at least GCC 13 and link against C++23.&lt;/p>
&lt;p>The performance benefits are very close to what expression templates provide; at much less maintainability cost; but the uncertainty around them is much higher because of the thin support.&lt;/p>
&lt;div class="alert alert-warning" role="alert">
&lt;h4 class="alert-heading">Warning&lt;/h4>
NVIDIA&amp;rsquo;s HPC c++ compilers at the moment support only C++17; &lt;a href="https://developer.nvidia.com/blog/accelerating-standard-c-with-gpus-using-stdpar/">using stdpar&lt;/a> will prove difficult if decided to use views. So, for now, it&amp;rsquo;s either to optimize for CPU; &lt;strong>or&lt;/strong> use the GPU. We can&amp;rsquo;t do both as working comfortably with views requires C++23.
&lt;/div>
&lt;p>Thus, building a system on top of views is probably not a good idea when it comes to API stability. But there is always the &lt;a href="https://github.com/ericniebler/range-v3">ranges-v3&lt;/a> library which will hopefully cover anything that the standard libraries might miss. My only concern is that I will not have enough time to wait for standard updates; if anything is missing in c++23 standard library, I will have to switch to &lt;code>ranges-v3&lt;/code> for quite some time or ditch the idea.&lt;/p>
&lt;h2 id="the-benchmarks">The benchmarks&lt;/h2>
&lt;p>You can take a look at the benchmark results at &lt;a href="https://github.com/FoamScience/Eager-TemplateExpr-Views-OpenFOAM/actions/runs/6332376505/job/17198740304">this dedicated repository&lt;/a> (at the end of compile and test step) which reflect what is shown in the animation above (&lt;code>m&lt;/code>, &lt;code>rho&lt;/code>, &amp;hellip;, etc are all scalar fields). The CI workflows there perform the benchmarks on Github machines (which are not the fastest) so, compared to HPC nodes, results are a little exaggerated.&lt;/p>
&lt;p>The correctness and performance of the testing code are recorded by &lt;a href="https://github.com/FoamScience/foamUT">foamUT&lt;/a>; my unit-testing framework for OpenFOAM code (hence MeshFreeFoam too).&lt;/p>
&lt;p>For the sake of exploring the effects of template expressions, I stole and used a &lt;a href="https://gieseanw.wordpress.com/2019/10/20/we-dont-need-no-stinking-expression-templates/">trivial implementation&lt;/a>:&lt;/p>
&lt;div class="td-card card border me-4">
&lt;div class="card-header bg-white">
Template expression for binary operations on containers in C++
&lt;/div>
&lt;div class="card-body code p-0 m-0">
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-CPP" data-lang="CPP">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">template&lt;/span>&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">T&lt;/span>, &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">U&lt;/span>, &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Callable&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">BinaryContainerExpression&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">template&lt;/span>&lt;span style="color:#333">&amp;lt;&lt;/span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Func&lt;/span>&lt;span style="color:#333">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BinaryContainerExpression(&lt;span style="color:#080;font-weight:bold">const&lt;/span> T&lt;span style="color:#333">&amp;amp;&lt;/span> _left, &lt;span style="color:#080;font-weight:bold">const&lt;/span> U&lt;span style="color:#333">&amp;amp;&lt;/span> _right, Func&lt;span style="color:#333">&amp;amp;&amp;amp;&lt;/span> _callable) &lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_{&lt;span style="color:#333">&amp;amp;&lt;/span>_left},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> right_{&lt;span style="color:#333">&amp;amp;&lt;/span>_right},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> callable_{std&lt;span style="color:#333">::&lt;/span>forward&lt;span style="color:#333">&amp;lt;&lt;/span>Func&lt;span style="color:#333">&amp;gt;&lt;/span>(_callable)}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(_left.size() &lt;span style="color:#333">==&lt;/span> _right.size());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">auto&lt;/span> &lt;span style="color:#080;font-weight:bold">operator&lt;/span>[](size_t index) &lt;span style="color:#080;font-weight:bold">const&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#06b;font-weight:bold">callable_&lt;/span>((&lt;span style="color:#333">*&lt;/span>left_)[index], (&lt;span style="color:#333">*&lt;/span>right_)[index]);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size_t &lt;span style="color:#06b;font-weight:bold">size&lt;/span>() &lt;span style="color:#080;font-weight:bold">const&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> left_&lt;span style="color:#333">-&amp;gt;&lt;/span>size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> T&lt;span style="color:#333">*&lt;/span> left_&lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> U&lt;span style="color:#333">*&lt;/span> right_&lt;span style="color:#333">=&lt;/span> &lt;span style="color:#080;font-weight:bold">nullptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Callable callable_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/div>
&lt;div class="card-footer">
Not suitable for production code. I&amp;rsquo;m sure I can add syntactic sugar, but that&amp;rsquo;s not the point.&lt;/div>
&lt;/div>
&lt;p>It&amp;rsquo;s worth noting that on &lt;a href="https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supported-runners-and-hardware-resources">GitHub machines&lt;/a> the execution time of lazy evaluations is a third of that of eager evaluations; while on my local machine, it&amp;rsquo;s around 50%. For the record, the test machine has the following properties:&lt;/p>
&lt;pre tabindex="0">&lt;code>System: Kernel: 5.15.0-10078* x86_64 bits: 64 compiler: N/A Desktop: Gnome 3.36.9
Distro: Ubuntu 20.04.6 LTS (Focal Fossa)
CPU: Topology: 8-Core model: AMD Ryzen 7 5800H with Radeon Graphics bits: 64 type: MT MCP arch: Zen 3 L2 cache: 4096 KiB
flags: avx avx2 lm nx pae sse sse2 sse3 sse4_1 sse4_2 sse4a ssse3 svm bogomips: 102207
Speed: 1254 MHz min/max: 1200/3200 MHz Core speeds (MHz): 1: 1275 2: 1191 3: 1139 4: 1227 5: 1134 6: 1135 7: 1297
8: 1296 9: 1135 10: 1135 11: 1135 12: 1133 13: 1286 14: 1171 15: 1517 16: 1161
&lt;/code>&lt;/pre>&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>If GPU acceleration is not important, &lt;code>Views&lt;/code> are the best course of action. This idea might fail horribly though, as everything else.&lt;/p></description></item><item><title>Blog: A reflection system for MeshFreeFoam: Part 1</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/29/a-reflection-system-for-meshfreefoam-part-1/</link><pubDate>Fri, 29 Sep 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/29/a-reflection-system-for-meshfreefoam-part-1/</guid><description>
&lt;h2 id="motivation">Motivation&lt;/h2>
&lt;p>&lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/27/lazy-evaluation-part-1/">Lazy evaluation&lt;/a> is not the only thing I envy in &lt;code>.Net&lt;/code> languages. It&amp;rsquo;s one of two things, the other being &lt;strong>their runtime reflection systems&lt;/strong>. This feature is not exclusive to .Net languages; it&amp;rsquo;s found in all reflective languages (e.g., JavaScript, Java, Python, Go, Julia, etc.), except for C++.&lt;/p>
&lt;p>The perfect implementation of a reflection system for OpenFOAM-based code will:&lt;/p>
&lt;ol>
&lt;li>Be fully implemented at compile-time (with zero runtime cost) but allow access to reflection information at runtime.&lt;/li>
&lt;li>Be compatible with the runtime selection mechanism.&lt;/li>
&lt;li>Support automatic serialization to JSON/XML for creating objects from a Web UI (or a TUI for that matter).&lt;/li>
&lt;li>Support building efficient proxy classes for objects to expose (private? protected?) fields to Web UI widgets.&lt;/li>
&lt;/ol>
&lt;h2 id="current-plans">Current plans&lt;/h2>
&lt;p>It doesn&amp;rsquo;t seem like a lot of work, but the challenges lie in meeting my specific requirements 1 and 2 above. There are few ways to achieve this:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://youtu.be/DUiUBt-fqEY">Building a C++ Reflection System in One Weekend Using Clang and LLVM&lt;/a> demonstrates a method using compiler magic to generate reflection code. It parses the headers&amp;rsquo; AST and generates C++ files to include in the final compilation units. This approach is not preferred due to two main reasons:&lt;/p>
&lt;ul>
&lt;li>It requires annotating classes and fields for reflection.&lt;/li>
&lt;li>A separate tool must run on the classes&amp;rsquo; headers with the correct compiler flags set to generate the reflection code, adding maintenance overhead.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/veselink1/refl-cpp">refl-cpp&lt;/a> implements a version without parsing the AST, which is the preferred approach. It will serve as the main inspiration for developing the reflection system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://clementpirelli.wordpress.com/2021/12/08/cpp-reflection-ts-first-look/">C++ Reflection TS&lt;/a> can be option for future projects. But as, at best, It&amp;rsquo;ll make into the standard by c++26, and we&amp;rsquo;ll have to wait for 1-2 years for compiler support, it&amp;rsquo;s better if we don&amp;rsquo;t rely on such experimental proposals. Currently, only &lt;code>clang&lt;/code> can compile code from the proposal.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>Work on this front will begin as soon as I can visualize the meshfree domain (i.e., the particles) with ParaView. Immediate issues that must be addressed include:&lt;/p>
&lt;ul>
&lt;li>Ensuring both the reflection system and the runtime selection mechanism can coexist smoothly.&lt;/li>
&lt;li>Exposing fields of default OpenFOAM types (e.g., &lt;code>List&lt;/code>, &lt;code>triSurface&lt;/code>, etc.), which may not be trivial.&lt;/li>
&lt;/ul></description></item><item><title>Blog: A reflection system for MeshFreeFoam: Part 2</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/10/02/a-reflection-system-for-meshfreefoam-part-2/</link><pubDate>Mon, 02 Oct 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/10/02/a-reflection-system-for-meshfreefoam-part-2/</guid><description>
&lt;p>The &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/29/a-reflection-system-for-meshfreefoam-part-1/">previous post&lt;/a> a few days ago introduced the idea of leveraging a reflection system to automatically build UIs for MeshFreeFoam classes that stay up to date with code changes.&lt;/p>
&lt;p>In this post, I outline what&amp;rsquo;s currently possible, what&amp;rsquo;s not, and what&amp;rsquo;s missing.&lt;/p>
&lt;h2 id="ui-for-openfoam-rts-based-models-what-works">UI for OpenFOAM RTS-based models (What works)&lt;/h2>
&lt;p>Imagine if you can have the following base model class, which acts as a base for OpenFOAM&amp;rsquo;s runtime selection table:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">baseModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">protected&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label m_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector vv_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeName(&lt;span style="background-color:#fff0f0">&amp;#34;baseModel&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> declareRunTimeSelectionTable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autoPtr,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> baseModel,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dictionary,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> dictionary&lt;span style="color:#333">&amp;amp;&lt;/span> dict
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (dict)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> autoPtr&lt;span style="color:#333">&amp;lt;&lt;/span>baseModel&lt;span style="color:#333">&amp;gt;&lt;/span> New(&lt;span style="color:#080;font-weight:bold">const&lt;/span> dictionary&lt;span style="color:#333">&amp;amp;&lt;/span> dict);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defineTypeNameAndDebug(baseModel, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defineRunTimeSelectionTable(baseModel, dictionary);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And a number of derived models; participating in the runtime selection using a dictionary:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">childModel&lt;/span> &lt;span style="color:#333">:&lt;/span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> baseModel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">protected&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> word type_;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span>&lt;span style="color:#333">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TypeName(&lt;span style="background-color:#fff0f0">&amp;#34;childModel&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>defineTypeNameAndDebug(childModel, &lt;span style="color:#00d;font-weight:bold">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>addToRunTimeSelectionTable(baseModel, childModel, dictionary);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>How useful would it be to &lt;strong>automatically&lt;/strong> generate a schema of the required dictionary entries for &lt;strong>each model&lt;/strong>?&lt;/p>
&lt;p>Well, what if you could:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>Info &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> generateSchema&lt;span style="color:#333">&amp;lt;&lt;/span>childModel&lt;span style="color:#333">&amp;gt;&lt;/span>() &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>and get the following output (note how members from the base class get picked up too! and how correct defaults get chosen for each member):&lt;/p>
&lt;pre tabindex="0">&lt;code>{
type_ &amp;#34;&amp;#34;;
m_ 0;
vv_ ( 0 0 0 );
}
&lt;/code>&lt;/pre>&lt;p>Up to this level; we can do this with the assist of reflections. In fact, this has nothing to do with the RTS. It can be done to any class. Here is a quick animation illustrating the Interactive UI application from &lt;a href="https://github.com/FoamScience/openfoam-reflections">openfoam-reflections&lt;/a>:&lt;/p>
&lt;div style="position:relative;padding-bottom:56.25%;">
&lt;iframe style="width:100%;height:100%;position:absolute;left:0px;top:0px;" frameborder="0" width="100%" height="100%" allowfullscreen="" allow="autoplay" src="./ReflectionsRTSAnimation.html">
&lt;/iframe>
&lt;/div>
&lt;h2 id="ui-for-openfoam-rts-based-models-what-doesnt-work">UI for OpenFOAM RTS-based models (What doesn&amp;rsquo;t work)&lt;/h2>
&lt;p>Pushing it a little further, can we walk users through the process of generating a valid dictionary for a &lt;code>baseModel&lt;/code> to be constructed (!automatically!)? Envision the following workflow in case &lt;code>baseModel&lt;/code> is both &lt;strong>an abstract class&lt;/strong> and &lt;strong>a base for dictionary-based runtime selection&lt;/strong>:&lt;/p>
&lt;ol>
&lt;li>Prompt users to pick a valid child for &lt;code>baseModel&lt;/code> (In this case, present them with &lt;code>childModel&lt;/code> as the only option)&lt;/li>
&lt;li>Keep prompting them for required members of &lt;code>childModel&lt;/code>. Naturally we don&amp;rsquo;t want to hardcode the logic there; we want the compiler to generate the required code for us. This way, as we add class members, we won&amp;rsquo;t have to change the UI code.&lt;/li>
&lt;/ol>
&lt;p>Well, it turns out we can achieve the first step by looking into the runtime selection table. But the next step is tricky since there will be a need to convert a string (user input) to a C++ type. The runtime selection table itself gets around this issue by keeping pointers to constructors. It&amp;rsquo;s not obvious to me how can we get hold of the concrete type at the moment. In addition, because the reflection is done at compile-time, the &lt;code>childModel&lt;/code> header needs to be included in the UI code, which defeats the purpose of the RTS.&lt;/p>
&lt;p>Also, some special members will need to be handled explicitly, such as having an &lt;code>autoPtr&amp;lt;something&amp;gt;&lt;/code> that initiates another RTS model.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>While the adopted reflection system has a variety of uses such as iterating over class&amp;rsquo;s member fields and functions, iterating over bases of a class, and even building powerful proxies, using to reflect RTS types doesn&amp;rsquo;t seem possible at the moment.&lt;/p></description></item><item><title>Blog: A reflection system for MeshFreeFoam: Part 3</title><link>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/10/05/a-reflection-system-for-meshfreefoam-part-3/</link><pubDate>Thu, 05 Oct 2023 00:00:00 +0000</pubDate><guid>https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/10/05/a-reflection-system-for-meshfreefoam-part-3/</guid><description>
&lt;p>The &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/10/02/a-reflection-system-for-meshfreefoam-part-2/">previous post&lt;/a> outlined the main challenges in implementing a decent reflection system for OpenFOAM while preserving the benefits of the runtime selection mechanism.&lt;/p>
&lt;p>In this post, I describe the final state of the system and its limitations, along with some implementation details.&lt;/p>
&lt;h2 id="make-classes-reflect-themselves">Make classes reflect themselves?&lt;/h2>
&lt;p>From the previous post, we have deduced that it is mainly possible to automatically generate a schema for a class. The only case where generating such a schema proves difficult is when nesting RTS models. So, let&amp;rsquo;s explore how this issue can be resolved. Assume the following abstract base class, which has a few reflected members:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#579"># These are only reflected members of baseModel, it can have non-reflected ones
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#579">&lt;/span>baseModel
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">|--&amp;gt;&lt;/span> key_ (autoPtr&lt;span style="color:#333">&amp;lt;&lt;/span>word&lt;span style="color:#333">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">|--&amp;gt;&lt;/span> m_ (label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#333">|--&amp;gt;&lt;/span> vv_ (Vector&lt;span style="color:#333">&amp;lt;&lt;/span>scalar&lt;span style="color:#333">&amp;gt;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>For the sake of code maintainability, let&amp;rsquo;s say that we have a static member of a template class &lt;code>builder&amp;lt;T&amp;gt;::schema()&lt;/code> which returns the following dictionary if executed with &lt;code>[T = baseModel]&lt;/code> (note that the RTS mechanism is consulted for available model options):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> baseModelType &lt;span style="background-color:#fff0f0">&amp;#34;__one of ( childModel childModel1 childModel2 )__&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key &lt;span style="background-color:#fff0f0">&amp;#34;__optional Foam::word here__&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vv ( &lt;span style="color:#00d;font-weight:bold">0&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Such schema is possible to achieve entirely because of the compile-time reflection system and C++ concepts. But notice that once a user chooses an implemented model, the schema will be missing the members from the chosen &lt;code>childModel&lt;/code>.&lt;/p>
&lt;p>A simple test of such schema methods:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#339;font-weight:bold">bool&lt;/span> hasSchema &lt;span style="color:#333">=&lt;/span> SelfReflectableModel&lt;span style="color:#333">&amp;lt;&lt;/span>childModel&lt;span style="color:#333">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">if&lt;/span> &lt;span style="color:#06b;font-weight:bold">constexpr&lt;/span> (hasSchema) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dict &lt;span style="color:#333">=&lt;/span> schema&lt;span style="color:#333">&amp;lt;&lt;/span>childModel&lt;span style="color:#333">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>will result in the following schema:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
baseModelType childModel;
type ;
subModel
{
baseModelType &amp;#34;__one of ( childModel childModel1 childModel2 )__&amp;#34;;
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
&lt;/code>&lt;/pre>&lt;p>for a child type which has the following members (Both the nested RTS model &lt;code>subModel_&lt;/code> and the &lt;code>type_&lt;/code> member now show up in the schema):&lt;/p>
&lt;pre tabindex="0">&lt;code>childModel : public baseModel
|--&amp;gt; type_ (word)
|--&amp;gt; subModel_ (autoPtr&amp;lt;baseModel&amp;gt;)
&lt;/code>&lt;/pre>&lt;blockquote>
&lt;p>From this experiment, we deduce that generating schemas for abstract base classes is way less important than for concrete implementations of the target models.&lt;/p>
&lt;/blockquote>
&lt;p>Note that the previous C++ code snippet features &lt;strong>compile-time if statements&lt;/strong> which execute the schema method only if the target type is self-reflectable (a fancy way to say: the type has a &lt;code>schema&lt;/code> method). If it is not the case, the compiler generates no code. Hence, the runtime cost occurs only if the type is self-reflectable, in which case, an OpenFOAM dictionary is built from the target type&amp;rsquo;s members.&lt;/p>
&lt;p>In addition, concepts help generate code for specific cases. A good example is to fill the dictionary values with default-constructed values of the members only if the member type is default-constructible.&lt;/p>
&lt;p>Special cases for some class members can be also treated. As an example, take a member which is an &lt;code>autoPtr&amp;lt;Something&amp;gt;&lt;/code>. If the member points to a RTS-managed type (such us &lt;code>baseModel&lt;/code>, &lt;code>childModel&lt;/code>&amp;hellip; etc), we will want to execute the schema function from that type. This is how the schema for the &lt;code>childModel::subModel_&lt;/code> for example is generated while generating the schema for &lt;code>childModel&lt;/code>.&lt;/p>
&lt;p>In the case of the pointed-to member type is not RTS-managed (eg. a simple &lt;code>word&lt;/code> as in &lt;code>childModel::key_&lt;/code>), we can assume that it&amp;rsquo;s an optional input and hint that assumption to the end user!&lt;/p>
&lt;h2 id="runtime-selection-to-the-rescue">Runtime selection to the rescue&lt;/h2>
&lt;p>Reflection is traditionally tailored towards POD ( plain-old-data, which define little behavior ) structures, and using it together with the runtime selection mechanism proves to be difficult. One of the main issues that we particularly need the classes to generate their schema on their own is that we don&amp;rsquo;t want to include all headers in the application (include only those of the base classes), and allow users to dynamically load their libraries). One way of doing this would be to make the &lt;code>schema&lt;/code> method an &lt;strong>abstract method&lt;/strong> on base classes.&lt;/p>
&lt;p>On the other hand, we need to generate a schema without creating any objects of the target type, so &lt;code>schema&lt;/code> must also be &lt;strong>static&lt;/strong>. Since there is no such thing as a &lt;strong>static virtual method&lt;/strong>, we have to resolve this in another way.&lt;/p>
&lt;p>These conflicting interests are the exact reason behind the runtime selection mechanism, so we can simply abuse to, instead of building a table of constructors, build a table of function points which points to a free method (or a static in a template class):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// The table of function pointers (for illustration purposes only, function pointers are not stored like this)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> childModel &lt;span style="color:#333">&amp;amp;&lt;/span>builder&lt;span style="color:#333">&amp;lt;&lt;/span>childModel&lt;span style="color:#333">&amp;gt;::&lt;/span>schema()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> childModel1 &lt;span style="color:#333">&amp;amp;&lt;/span>builder&lt;span style="color:#333">&amp;lt;&lt;/span>childModel1&lt;span style="color:#333">&amp;gt;::&lt;/span>schema()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> childModel2 &lt;span style="color:#333">&amp;amp;&lt;/span>builder&lt;span style="color:#333">&amp;lt;&lt;/span>childModel2&lt;span style="color:#333">&amp;gt;::&lt;/span>schema()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Then we leverage the same mechanism &lt;code>::New&lt;/code> uses to create objects by looking up the table for the model we want; and then call the function through the stored function pointer.&lt;/p>
&lt;h2 id="a-recap-of-the-api-to-generate-model-schemas">A recap of the API to generate model schemas&lt;/h2>
&lt;p>The base block for the whole mechanism would be a static member method to generate a schema for the target type &lt;code>T&lt;/code>. This method has to have all desired features (eg. can call itself if a member of &lt;code>T&lt;/code> is an &lt;code>autoPtr&amp;lt;U&amp;gt;&lt;/code> if U is also an RTS-managed class):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>dictionary builder&lt;span style="color:#333">&amp;lt;&lt;/span>T&lt;span style="color:#333">&amp;gt;::&lt;/span>schema()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The next layer is a set of static members that need to be present on the base class. Basically, a hash table of regular function pointers, and a few methods to construct and destroy the table. A subclass to the base class is also need so we can use to add children to the table. All of this can be hidden behind a few macros easily.&lt;/p>
&lt;p>Similarly to &lt;code>::New()&lt;/code>, base classes then can have a &lt;code>baseModel::schema(const word&amp;amp;)&lt;/code> static method which looks up the hash table for the passed-in model type name and calls the corresponding function.&lt;/p>
&lt;p>The child classes will also have to initialize a static member for a specific type so they get added to the hash table automatically (static initialization happens before &lt;code>main&lt;/code>).&lt;/p>
&lt;p>Let&amp;rsquo;s look at a full application example, which presents the user with available options for a &lt;code>baseModel&lt;/code> and generates a schema for &lt;strong>the chosen concrete implementation&lt;/strong>:&lt;/p>
&lt;blockquote>
&lt;p>Notice how there is no explicit mentioning of child classes.&lt;/p>
&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// OpenFOAM includes....
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#579">#include&lt;/span> &lt;span style="color:#579">&amp;#34;baseModel.H&amp;#34;&lt;/span>&lt;span style="color:#579">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#579">&lt;/span>&lt;span style="color:#339;font-weight:bold">int&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Info &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;Choose a Model from available baseModels:&amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Info &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> mff&lt;span style="color:#333">::&lt;/span>baseModel&lt;span style="color:#333">::&lt;/span>schemasPtr_&lt;span style="color:#333">-&amp;gt;&lt;/span>toc() &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> word modelType;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#333">::&lt;/span>getline(std&lt;span style="color:#333">::&lt;/span>cin, modelType);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Info &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;Here is how you&amp;#39;re supposed to construct a &amp;#34;&lt;/span> &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> modelType &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Info &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> mff&lt;span style="color:#333">::&lt;/span>baseModel&lt;span style="color:#333">::&lt;/span>schema(modelType) &lt;span style="color:#333">&amp;lt;&amp;lt;&lt;/span> endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>{
baseModelType childModel;
type ;
subModel
{
baseModelType &amp;#34;__one of ( childModel childModel1 childModel2 )__&amp;#34;;
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
&lt;/code>&lt;/pre>&lt;p>&lt;strong>Beautiful!&lt;/strong> ðŸŽ‰ ðŸ¥³&lt;/p>
&lt;h2 id="going-the-extra-mile">Going the extra-mile&lt;/h2>
&lt;p>There a couple of loose ends to tie up:&lt;/p>
&lt;h3 id="defaulted-values-for-members">Defaulted values for members???&lt;/h3>
&lt;p>As it stands now, the schemas will suggest default values for members as in &amp;ldquo;default values for C++ types&amp;rdquo;. It would be interesting if we could extract the actual default values of the members as used in the target&amp;rsquo;s type construction (They properly have more physical meaning)!&lt;/p>
&lt;p>This turns out not be so easy. One idea that comes to mind is to first create a schema for the target type ignoring all optional members; then use that schema to actually create an object of the target type. From there, it only remains to check the values of the optional members.&lt;/p>
&lt;p>But this is not possible since objects can be created from all kinds of objects (and not just from a dictionary) and restricting that doesn&amp;rsquo;t look like a good idea.&lt;/p>
&lt;p>To achieve this effect, we would have to use complex members holding their metadata; such as:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">baseModel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">alpha&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> min_ &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> max_ &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">10&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">const&lt;/span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> default_ &lt;span style="color:#333">=&lt;/span> &lt;span style="color:#00d;font-weight:bold">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> std&lt;span style="color:#333">::&lt;/span>string_view name_ &lt;span style="color:#333">=&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;alpha&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">constexpr&lt;/span> std&lt;span style="color:#333">::&lt;/span>string_view description_ &lt;span style="color:#333">=&lt;/span> &lt;span style="background-color:#fff0f0">&amp;#34;cool description of alpha&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#339;font-weight:bold">int&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } alpha;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We could then use &lt;code>alpha.default&lt;/code> to initialize &lt;code>alpha&lt;/code>; and it is accessible through the reflection system. Since it&amp;rsquo;s a &lt;code>constexpr&lt;/code>; this adds no runtime costs. The thing is, the default value for non-linear types will need to be initialized out-of-line. Using the reflection system for default values is possible for literal types only since non-literals cannot generally be &lt;code>constexpr&lt;/code> (at the moment, there is no support for &lt;code>constexpr std::vector&lt;/code> in any compiler!).&lt;/p>
&lt;h3 id="complete-nested-model-schemas">Complete nested model schemas???&lt;/h3>
&lt;p>If we look closely at the generated schema from the previous example:&lt;/p>
&lt;pre tabindex="0">&lt;code>{
baseModelType childModel;
type ;
subModel
{
baseModelType &amp;#34;__one of ( childModel childModel1 childModel2 )__&amp;#34;;
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
key &amp;#34;__optional Foam::word here__&amp;#34;;
m 0;
vv ( 0 0 0 );
}
&lt;/code>&lt;/pre>&lt;p>we can see that the &lt;code>subModel&lt;/code> shows only members of the base class. To make it show the full array of members of the concrete type, the user can be prompted to pick a valid model, and then &lt;code>baseModel::schema(&amp;quot;pickedModel&amp;quot;)&lt;/code> will be called inside &lt;code>builder::schema&amp;lt;baseModel&amp;gt;()&lt;/code> instead of calling &lt;code>builder::schema&amp;lt;memberBaseType&amp;gt;()&lt;/code>. This scenario is particularly useful in building GUIs.&lt;/p>
&lt;h2 id="conclusion">Conclusion&lt;/h2>
&lt;p>At this point, all of the design goals mentioned back in &lt;a href="https://foamscience.github.io/MeshFreeFoam-Docs/blog/2023/09/29/a-reflection-system-for-meshfreefoam-part-1/">Part 1&lt;/a> have been achieved. Except for minor changes, I will not develop the system any further.&lt;/p>
&lt;p>Use cases are exclusively &lt;strong>(automatically) generating schemas for OpenFOAM classes&lt;/strong> and &lt;strong>(again automatically) building GUI widgets for target types&lt;/strong>&lt;/p>
&lt;p>You can find the final product with a sample application to iteratively generate a dictionary for some basic models at &lt;a href="https://github.com/FoamScience/openfoam-reflections">FoamScience/openfoam-reflections&lt;/a>.&lt;/p></description></item></channel></rss>